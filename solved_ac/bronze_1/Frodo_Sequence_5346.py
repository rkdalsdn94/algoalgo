# 백준 - 브론즈1 - Frodo Sequence - 5346 - 수학, 사칙연산 문제
'''
수학, 사칙연산 문제

제일 처음 다른 dp 문제를 풀 때와 같이 풀었는데, 메모리 초과가 나왔다. (아래 틀린 코드, n의 최대값이 2^31이라 메모리 초과)
    dp = [0] * (n + 1)
    dp[1] = 1
    dp[2] = 1
    dp[3] = 2

    for i in range(4, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2] - dp[i - 3]
따라서 다른 방식으로 풀어야 되는데, 어차피 마지막 값을 기억하면 되는 문제여서 dp 배열을 4개만 만들어서 풀었다.
다 풀고 다른 사람의 코드를 보니 이렇게 풀지 말고 n을 1 더해서 2로 나눈 몫을 출력하면 되는 문제였다..

풀이 과정
    1. 입력을 받는다.
    2. n이 0이면 종료한다.
    3. n이 1이거나 2이면 1을 출력하고, 다음으로 넘어간다.
    4. n이 3이면 2를 출력하고, 다음으로 넘어간다.
    5. dp를 만들어 0으로 초기화한다.
    6. dp[1] = 1, dp[2] = 1, dp[3] = 2로 초기화한다.
    7. 4부터 n까지 dp[0]에 dp[2] + dp[3] - dp[1]을 넣는다.
    8. dp[1], dp[2], dp[3] = dp[2], dp[3], dp[0]으로 초기화한다.
    9. dp[3]을 출력한다.
'''

while 1:
    n = int(input())
    if n == 0:
        break
    elif n == 1 or n == 2:
        print(1)
        continue
    elif n == 3:
        print(2)
        continue

    dp = [0] * 4
    dp[1] = 1
    dp[2] = 1
    dp[3] = 2

    for i in range(4, n + 1):
        dp[0] = dp[2] + dp[3] - dp[1]
        dp[1], dp[2], dp[3] = dp[2], dp[3], dp[0]

    print(dp[3])

'''
다른 사람 풀이

while True :
    n = int(input())
    if n == 0:
        break

    print((n + 1) // 2)
'''
