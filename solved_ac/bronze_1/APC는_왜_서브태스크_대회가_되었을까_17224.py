# 백준 - 브론즈1 - APC는 왜 서브태스크 대회가 되었을까 - 17224 - 그리디, 정렬 문제
'''
그리디, 정렬 문제

단순한 그리디와 정렬을 이용한 문제다.

최대한 높은 점수를 획득하려면 어려운 문제를 많이 풀어야 된다.
즉, 입력으로 들어온 n_list에서 1번째 인덱스의 문제를 더 많이 풀어야 된다.
하지만 문제를 풀 수 있는 최대 개수(k)가 존재하므로 풀 수 있는 어려운 문제 많이 풀어야 된다.
따라서, 어려운 문제를 기준으로 오름차순 정렬한 뒤,
    - 어려운 문제를 풀 수 있을 때(hard <= l)마다 140점과, 문제를 풀었다는 표시를 하기 위해 cnt를 1 증가시킨다.
    - 어려운 문제를 못 풀면 쉬운 문제를 풀 수(easy <= l) 있는지 검사한 뒤 100점을 추가하고 위와 같이 cnt를 1 증가시킨다.
이러한 방식으로 cnt가 k와 같이 되거나, 입력으로 들어온 n_list의 값의 순회를 끝났을 때 res를 출력하면 된다.
'''


n, l, k = map(int, input().split())
n_list = sorted([list(map(int, input().split())) for _ in range(n)], key=lambda x: x[1])

# 테스트
# n, l, k = 4, 8, 4
# n_list = sorted([[1, 8], [4, 5], [6, 20], [9, 12]], key=lambda x: x[1]) # 380
# n, l, k = 8, 7, 5
# n_list = sorted([[1,3], [2,5], [3,5], [4,8], [5,8], [6,9], [6,7], [7,10]], key=lambda x: (x[1], x[0])) # 660
# n, l, k = 8, 9, 5
# n_list = sorted([[1,8], [3,10], [4,5], [5,20], [7,12], [8,15], [9,50], [14,14]], key=lambda x: (x[1], x[0])) # 580

cnt, res = 0, 0

for easy, hard in n_list:
    if cnt == k:
        break

    if hard <= l:
        res += 140
        cnt += 1
    elif easy <= l:
        res += 100
        cnt += 1

print(res)
