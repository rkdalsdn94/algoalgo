# 백준 - 브론즈1 - 임시 반장 정하기 - 1268 - 구현 문제
'''
구현 문제

브론즈 1 문제인데 시간이 생가보다 꽤 걸렸다. 문제를 알고리즘을 풀 때 구현력에 대해 아직 부족하다는 느낌이 들었다.
문제 난이도가 높은 것들을 풀 때엔 보통 해당 알고리즘만 적용하는 식으로 풀어서 잘 풀 수 있었던 건데 '구현은 잘 풀 수 있지'라며 착각하고 있었다.

우선 이 문제에 풀이는 1 ~ 5 학년 동안 같은 반이 있던 학생들의 ck 리스트 index를 1로 바꾼다. -> (ck 리스트는 n의 범위까지 0으로 초기화되어 있다.)
해당 ck 리스트의 한 줄(학생) 씩 꺼내 res에 각 줄(학생)에서 같은 반이 있었는지 체크한 1의 개수를 count 해 res에 담고,
res에서 가장 큰 값의 인덱스를 + 1 한 상태로 출력하면 풀린다.

처음에 i, j, k의 반복문에 대해서 구현하기까지 시간이 꽤 걸렸었다.
머릿속으론 어떻게 푸는지 알겠는데 그 방법을 코드로 옮기는 과정과, 해당 코드가 내 머리랑 다르게 동작할 때도 있었다.
다른 알고리즘을 공부하는 것도 좋은데, 머리에서 생각한 코드랑 손으로 옮길 때 코드랑 맞추는 연습을 좀 해야겠다는 생각이 많이 들었던 문제이다.
당분간 기초적인 구현 문제들이라도 연습을 해야겠다.
'''

import sys; input = sys.stdin.readline

n = int(input())
board = [ list(map(int, input().split())) for _ in range(n) ]

# 테스트
# n = 5
# board = [
#     [2, 3, 1, 7, 3], [4, 1, 9, 6, 8],
#     [5, 5, 2, 4, 4], [6, 5, 2, 6, 7], [8, 4, 2, 2, 2]
# ] # 4
# n = 3
# board = [
#     [1,2,3,4,5], [2,3,4,5,6], [3,4,5,6,7]
# ] # 1

ck = [ [0] * n for _ in range(n) ]
res = []

# 반복문으로 i학년일 때 같은 반을 찾는거
for i in range(5):
    for j in range(n):
        for k in range(j + 1, n):
            if board[j][i] == board[k][i]:
                ck[k][j] = 1
                ck[j][k] = 1

for i in ck:
    res.append(i.count(1))

print(res.index(max(res)) + 1)
