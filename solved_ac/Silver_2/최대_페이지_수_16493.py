# 백준 - 최대 페이지 수 - 16493 - 실버2 - dp, 배낭(knapsack), 완전 탐색 문제
'''
dp, 배낭(knapsack), 완전 탐색 문제

전형적인 배낭 문제이다.
최근에 풀었던 '평범한 배낭 - 12865' 문제랑 되게 유사하다.
이 문제도 1차원 배열로 풀고 싶었는 데 실패했다. 나중에 다시 도전해보면 재밌을거 같다.
당분간 배낭 문제를 풀어볼 생각이다.

풀이 과정
1. 입력값들을 잘 입력 받고, 정답을 출력할 dp 배열을 초기화 한다. -> dp의 바깥 크기를 m + 1로 잡아야 된다.
2. m_list의 0번째 인덱스에 [0, 0]를 추가(insert)한다.
3. input 값으로 들어온 책의 챕터만큼 반복하면서 반납날까지 반복문을 실행한다. -> 1부터 ~ m + 1까지 반복하면서 1부터 n + 1까지 2중 반복문
    3.1. 현재 진행 중인 날짜(j)의 값이 해당 챕터를 읽는데 드는 날짜(m_list[i][0])보다 많이 남았는지 검사한다. -> j >= m_list[i][0]
        3.1.1. 많이 남아 있다면 해당 챕터의 페이지 수를 더하고, 이 전의 값이랑 어떤 값이 더 큰지 비교해서 더 큰 값으로 갱신한다. -> max( ... )
              ㄴ> 이 전의 값 : dp[i - 1][j], dp[i - 1][j - m_list[i][0]]
                 해당 챕터를 읽는데 드는 비용(날짜)을 이 전의 값에서 빼고, 해당 챕터의 페이지 수를 더한다. : dp[i - 1][ j - m_list[i][0] ] + m_list[i][1]
        3.1.2. 더 적다면 이 전의 읽었던 챕터의 페이지 수로 해당 값을 갱신한다.
4. 최종 날짜와 마지막까지 max값으로 값을 갱신한 dp를 출력한다. -> dp[m][n]
'''

n, m = map(int, input().split())
m_list = [ list(map(int, input().split())) for _ in range(m) ]

# 테스트
# n, m = 7, 7
# m_list = [[3,10],[5,20],[1,10],[1,20],[2,15],[4,40],[2,200]] # 260
# n, m = 5, 3
# m_list = [[2,100],[2,20],[2,40]] # 140

dp = [ [0] * (n + 1) for _ in range(m + 1) ]
m_list.insert(0, [0, 0])

for i in range(1, m + 1):
    for j in range(1, n + 1):
        if j >= m_list[i][0]:
            dp[i][j] = max(dp[i - 1][j], dp[i - 1][ j - m_list[i][0] ] + m_list[i][1])
        else:
            dp[i][j] = dp[i - 1][j]

print(dp[m][n])
