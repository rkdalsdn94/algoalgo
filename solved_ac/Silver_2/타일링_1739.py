# 백준 - 실버2 - 타일링 - 1793 - dp 문제
'''
dp 문제

문제 분류 상에선 임의 정밀도 / 큰 수 연산이 있는데, python 에서는 크게 신경쓰지 않아도 된다.

피보나치 규칙에서 n을 손으로 풀어보면 답을 구할 수 있다.
input의 종료 조건이 없으므로 try except를 활용하고,
dp식은 dp[i] = dp[i - 1] + 2 * dp[i - 2] 이다.
n을 5 ~ 6 까지만 손으로 풀어보면 감을 얻을 수 있다.

in
    2
    8
    12
    100
    200
out
    3
    171
    2731
    845100400152152934331135470251
    1071292029505993517027974728227441735014801995855195223534251
'''

def fibo(n):
    if n == 0 or n == 1:
        return 1

    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 1
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + 2 * dp[i - 2]
    return dp[n]

while 1:
    try:
        n = int(input())
        print(fibo(n))
    except:
        break
