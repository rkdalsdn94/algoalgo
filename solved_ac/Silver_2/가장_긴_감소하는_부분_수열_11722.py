# 백준 - 가장 긴 감소하는 부분 수열 - 11722 - 실버2 - dp 문제
'''
dp 문제

범위가 작아 완전 탐색으로 전체 배열을 돌아도 문제를 풀 수 있다.
해당 방법으로 입력으로 주어진 배열 전체를 돌면서 작아질 때마다 1씩 더하면서 dp 값을 갱신해나가고 해당 dp에 max를 출력하면 된다.

풀이 과정
1. input을 잘 입력받고, dp 리스트를 n의 크기만큼 1로 초기화 한다.
2. 2중 반복문으로 1부터 시작한다.
    2.1 두 번째 반복문은 i 번째 까지 반복하면서 n_list의 j번째 값이 i번째 값보다 클 경우 dp 값을 갱신한다.
3. dp의 가장 큰 값을 반환한다.

다른 방식으론 역순으로 돌면 반복문을 한 번만 실행해도 될거 같다.
'''

n = int(input())
n_list = list(map(int, input().split()))

# 테스트
# n = 6
# n_list = [10,30,10,20,20,10] # 3

dp = [1] * n

for i in range(1, n):
    for j in range(i):
        if n_list[j] > n_list[i]:
            dp[i] = max(dp[i], dp[j] + 1)

print(max(dp))
