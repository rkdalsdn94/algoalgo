# 백준 - 오목 - 2072 - 실버2 - 구현, 시뮬레이션, bfs 문제
'''
구현, 시뮬레이션, bfs 문제

이 전의 같은 난이도의 오목(백준 2615) 문제를 풀었었는데 해당 문제보다 board의 진행 방향(dx, dy)에 대해서 좀 더 신경써야된다.

풀이 과정
1. n을 입력받고, 돌을 놓는 과정을 list형식으로 입력받는다.
2. 돌을 놓을 때마다 해당 돌의 색갈을 파악하기 위해 i를 2로 나눠서 돌의 색(color)을 구하고, board에서 돌을 놓는 부분도 해당 색으로 바꿔준다.
3. 내 코드상으로 보면 '위쪽, 오른쪽 위, 오른쪽, 오른쪽 아래, 아래, 왼쪽 아래, 왼쪽, 왼쪽 위' 형태로 각각의 방향마다 bfs를 실행한다.
    3.1 bfs를 실행할 때 현재 바둑돌을 놓는 좌표(a, b)랑 진행 중인 방향(j, z)을 인자로 넣고 실행한다.
4. bfs를 실행한다.
    4.1 deque를 만들고, 인자로 받은 좌표(x = a, y = b)를 deque에 넣는다.
    4.2 해당 좌표를 검사했는지 확인하기 위한 ck 변수를 board의 크기만큼 만든 후, 현재 입력으로 들어온 좌표를 방문했다는 1을 남긴다.
    4.3 참인지 확인할 cnt 변수를 1로 초기화한다.
    4.4 q를 꺼내면서 해당 좌표로 진행하는 방향과 해당 좌표의 반대 방향을 검사한다. -> 오른쪽을 검사하는 상황이면 왼쪽도 검사해야 된다.
        4.4.1 이때, 반대 방향을 검사하는 이유는 중간에 돌을 놓게 된 상황일수도 있으므로 검사해야 된다. -> i, j의 -를 붙여주면 된다.
             ex) '11011' -> '11111' 이 될 수도 있으므로 중간에 들어왔을 때 해당 방향의 반대값들도 검사해야 된다.
    4.5 위 방향대로 진행중에 board의 크기를 벗어나지 않고, 현재 돌의 색갈과 같고, 방문하지 않은 좌표면 cnt를 1더하고, 방문했다고 표시한 후 q에 추가한다.
    4.6 검사를 다 진행한 후 cnt의 값이 5이면 오목이 완성된 상황이므로 True을 리턴하고, 아닐경우 False를 리턴한다.
5. bfs가 참이 되면 i + 1을 출력한 후 프로그램을 종료한다.
6. n_list를 다 검사해도 참이 안나오면 -1을 출력한다.
'''

from collections import deque

n = int(input())
n_list = [ list(map(int, input().split())) for _ in range(n) ]

# 테스트
# n = 25
# n_list = [
#     [3,3], [2,3], [3,4], [2,2], [3,2],
#     [3,1], [3,5], [2,4], [2,5], [2,1],
#     [1,5], [4,1], [4,5], [5,5], [1,4],
#     [5,1], [1,3], [1,1], [5,3], [5,2],
#     [1,2], [5,4], [4,2], [4,4], [4,3],
# ] # 18

res = 0
board = [ [0] * 20 for _ in range(20) ]
dx, dy = [-1, -1, 0, 1, 1, 1, 0, -1], [0, 1, 1, 1, 0, -1, -1, -1]

def bfs(x, y, i, j):
    q = deque([(x, y)])
    ck = [ [0] * 20 for _ in range(20) ]
    ck[x][y] = 1
    cnt = 1

    while q:
        a, b = q.popleft()

        for aa, bb in [ [i, j], [-i, -j] ]:
            nx, ny = a + aa, b + bb

            if 0 <= nx < 20 and 0 <= ny < 20 and board[nx][ny] == color and ck[nx][ny] == 0:
                cnt += 1
                ck[nx][ny] = 1
                q.append([nx, ny])

    if cnt == 5:
        return True
    else:
        return False

for i in range(n):
    a, b = n_list[i]
    color = -1

    if i % 2 == 0:
        color = 2
        board[a][b] = 2
    else:
        board[a][b] = 1
        color = 1

    for j, k in zip(dx, dy):
        if bfs(a, b, j, k):
            print(i + 1)
            exit(0)

print(-1)
