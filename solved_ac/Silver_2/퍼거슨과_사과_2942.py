# 백준 - 실버2 - 퍼거슨과 사과 - 2942 - 수학, 정수론, 유클리드 호제법 문제
'''
수학, 정수론, 유클리드 호제법 문제

문제 분류에서 알 수 있듯이 최대 공약수를 찾고 최대 공약수의 약수들을 찾으면 되는 문제이다.
최근에 문제를 풀 때 최대 공약수를 math 모듈 내에 있는 gcd 함수를 이용했는데, 오랜만에 직접 구현했다.
처음에는 두 값의 최댓값의 절반(5억)이므로 괜찮을 줄 알았는데 시간 초과가 나왔다.
그래서 방식을 최대 공약수를 활용하는 방식으로 바궜다.
    - 시간 초과 코드는 제일 아래 있음

풀이 과정
1. 최대 공약수를 구하는 함수를 만든다.
    - b가 0이면 a를 반환하고, 아니면 b와 a % b를 인자로 넣어서 재귀를 돌린다.
2. 최대 공약수를 구한 뒤 루트를 씌운다.
3. 1부터 루트를 씌운 값까지 반복문을 돌린다.
    - 반복문을 돌리는 이유는 최대 공약수의 약수를 찾기 위함이다.
4. 반복문을 돌리면서 최대 공약수의 약수를 찾는다.
    - 최대 공약수의 약수를 찾는 방법은 최대 공약수를 i로 나눴을 때 나머지가 0이면 최대 공약수의 약수이다.
    - 최대 공약수의 약수를 찾았으면 최대 공약수와 최대 공약수를 i로 나눈 몫을 출력하면 된다.
    - 이때 최대 공약수와 최대 공약수를 i로 나눈 몫이 같은 경우는 제외해야 한다.
        - 이유는 같은 경우는 중복이기 때문이다.
'''

r, g = map(int, input().split())

# 테스트
# r, g = 4, 8
# '''
#     1 4 8
#     2 2 4
#     4 1 2
# '''
# r, g = 15, 12
# '''
#     3 5 4
#     1 15 12
# '''
# r, g = 42, 105
# '''
#     1 42 105
#     3 14 35
#     7 6 15
#     21 25
# '''

def gcd(a, b):
    if b == 0:
        return a
    else:
        return gcd(b, a % b)

gcd_num = gcd(r, g)

for i in range(1, int(gcd_num ** 0.5) + 1):
    if gcd_num % i == 0:
        print(i, r // i, g // i)

        if gcd_num // i == i: # 중복 방지
            continue

        temp = gcd_num // i
        print(temp, r // temp, g // temp)


'''
시간 초과

for i in range(1, max(r, g) // 2 + 1):
    a, b = r % i, g % i

    if a == 0 and b == 0:
        print(i, r // i, g // i)
'''
