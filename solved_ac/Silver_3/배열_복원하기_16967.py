# 백준 - 실버3 - 배열 복원하기 - 16967 - 구현 문제
'''
구현 문제

예제 1번을 보면 다음과 같다.
    1 2 3 4 0          1       2          3         4         0
    5 7 9 11 4     ->  5    (6 + 1)    (7 + 2)   (8 + 3)     4
    0 5 6 7 8          0       5          6         7        8
즉, 원본 행렬 A가 오른쪽으로 x만큼, 아래로 y만큼 이동한 행렬 B가 겹쳐진 것이므로 해당 값을 빼고 출력하면 된다.

풀이 과정
    1. 입력을 받는다.
    2. x, y부터 배열을 탐색한다.
    3. 배열의 값을 변경한다.
        3.1. i, j번째 배열의 값은 i - x, j - y번째 배열의 값과 같다.
            3.1.1. 이 부분은 위 예제 1번을 푼 것을 확인하면 된다.
    4. 배열을 출력한다.
'''

h, w, x, y = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(h + x)]

# 테스트
# h, w, x, y = 2, 4, 1, 1
# arr = [
#     [1, 2, 3, 4, 0],
#     [5, 7, 9, 11, 4],
#     [0, 5, 6, 7, 8]
# ] # 1 2 3 4  \  5 6 7 8
# h, w, x, y = 3, 3, 2, 1
# arr = [
#     [1, 2, 3, 0],
#     [4, 5, 6, 0],
#     [7, 9, 11, 3],
#     [0, 4, 5, 6],
#     [0, 7, 8, 9]
# ] # 1 2 3  \  4 5 6  \  7 8 9

for i in range(x, h):
    for j in range(y, w):
        arr[i][j] = arr[i][j] - arr[i - x][j - y]

for i in arr[:h]:
    print(*i[:w])
