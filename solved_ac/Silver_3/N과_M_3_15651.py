# 백준 - 실버3 - N과 M (3) - 15651 - 백 트래킹, 재귀 문제
'''
백 트래킹, 재귀 문제

백 트래킹? 재귀 방식으로 풀었다.
예전에 solved 로 풀기 전에 백준 문제 중 'N과 M (1)' 이 문제에서 중복 허용을 위해 if 조건만 없이 똑같이 풀면 되는 문제이다.

코드 설명은 재귀 함수로 구성된 recursive 함수 내에서
res 리스트의 길이가 m과 같아질 때 출력하고 return 하고,
길이가 같지 않을 경우 for 문으로 1부터 시작해서 n + 1까지 res에 담고, 다시 recursive 함수를 실행 시킨다.
for 문 내에서 recursive 함수가 종료 될 때 res를 pop 하면 된다.
'''

n, m = map(int, input().split())

# 테스트
# n, m = 3, 1 # 1  \  2  \  3
# n, m = 4, 2
# '''
#     1 1
#     1 2
#     1 3
#     1 4
#     2 1
#     2 2
#     2 3
#     2 4
#     3 1
#     3 2
#     3 3
#     3 4
#     4 1
#     4 2
#     4 3
#     4 4
# '''
# n, m = 3, 3
# '''
#     1 1 1
#     1 1 2
#     1 1 3
#     1 2 1
#     1 2 2
#     1 2 3
#     1 3 1
#     1 3 2
#     1 3 3
#     2 1 1
#     2 1 2
#     2 1 3
#     2 2 1
#     2 2 2
#     2 2 3
#     2 3 1
#     2 3 2
#     2 3 3
#     3 1 1
#     3 1 2
#     3 1 3
#     3 2 1
#     3 2 2
#     3 2 3
#     3 3 1
#     3 3 2
#     3 3 3
# '''

res = []

def recursive():
    if len(res) == m:
        print(*res)
        return
    
    for i in range(1, n + 1):
        res.append(i)
        recursive()
        res.pop()

recursive()
