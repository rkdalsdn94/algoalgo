# 백준 - 실버3 - 선린의 터를 - 21968 - 수학, 정수론, 비트마스킹 문제
'''
수학, 정수론, 비트마스킹 문제

문제 설명
    N의 이진수 표현에서 1인 비트의 위치가 어떤 3의 거듭제곱을 선택할지를 나타낸다.
    N=5일 때를 살펴보겠습니다:
        5의 이진수는 '101' 입니다.
    이는 오른쪽부터 읽어서:
        첫 번째 자리(1): 3⁰ = 1을 선택
        두 번째 자리(0): 3¹ = 3을 선택하지 않음
        세 번째 자리(1): 3² = 9를 선택
    따라서 5번째 선린의 터는 1 + 9 = 10이 됩니다.

핵심 아이디어
    - 입력값 N은 찾고자 하는 선린의 터의 순서를 나타내며, 이를 이진수로 표현했을 때
      각 자리의 비트는 해당 위치의 3의 거듭제곱을 선택할지 여부를 결정합니다.
    - 이진수의 각 자리(0 또는 1)에 대응하는 3의 거듭제곱을 곱하여 더함으로써
      N번째 선린의 터의 값을 효율적으로 계산할 수 있습니다.
    - 이 방법을 통해 모든 가능한 조합을 직접 생성하지 않고도 N번째 값을 구할 수 있습니다.

풀이 과정
    1. 테스트 케이스의 수 T를 입력받습니다.
    2. 각 테스트 케이스에 대해:
        2.1. 찾고자 하는 선린의 터의 순서 N을 입력받습니다.
        2.2. N을 이진수로 변환하며 각 비트를 digits 리스트에 저장합니다.
           이 과정에서 res에 3을 곱하여 자릿수 이동을 준비합니다.
        2.3. digits 리스트의 각 자리에 대해 3의 거듭제곱을 곱하여 더합니다.
           이는 선택된 3의 거듭제곱들의 합을 계산하는 과정입니다.
    3. 최종 계산된 선린의 터의 번호를 출력합니다.

in
    3
    1
    2
    123456789123
out
    1
    3
    217523656249693825
'''

t = int(input())
for _ in range(t):
    n = int(input())
    res = 0
    digits = []

    # N을 이진수로 변환하고 각 자리수 저장
    while n > 0:
        res *= 3  # 다음 자리로 이동할 때마다 3을 곱함
        digits.append(1 if n & 1 else 0)  # 현재 자리가 1인지 0인지 저장
        n >>= 1  # 다음 이진수 자리로 이동

    # 저장된 이진수 자리들을 이용해 3의 거듭제곱들의 합 계산
    exp3 = 1  # 3⁰부터 시작
    for digit in digits:
        res += digit * exp3  # 해당 자리가 1이면 현재 3의 거듭제곱을 더함
        exp3 *= 3  # 다음 3의 거듭제곱으로 이동

    print(res)
