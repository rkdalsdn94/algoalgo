# 백준 - 실버3 - 고양이 카페 - 28353 - 그리디, 완전 탐색, 정렬, 투 포인터 문제
'''
그리디, 완전 탐색, 정렬, 투 포인터 문제

정렬과 이분 탐색을 활용하면 풀 수 있는 문제이다.
고양이 무게로 들어오는 n_list를 정렬한 뒤, 제일 낮은 무게와 제일 높은 무게의 합이 k를 벗어나는지 비교하면서 값을 수정해나가면 된다.
만약 k를 넘어간다고 하면 제일 높은 무게인 right의 변수에서 1을 빼 무게를 낮추고,
넘어가지 않는다하면 left, right, res 를 각각 +1, -1, +1 하면 된다.

이해가 안 간다면 두 번째 예제를 손으로 풀어보면 된다.
[2 번째 예제 손으로 푸는 과정]
6마리의 고양이와 한 명이 버틸 수 있는 무게가 10이고,
각각의 고양이 무게는 [9, 5, 6, 7, 4, 3] 으로 되어 있다고 하자.
고양이 무게를 정렬하는건 정답 출력과 상관이 없으므로 정렬을 진행해도 상관이 없다 따라서 정렬을 진행하면 다음과 같다.
    [3, 4, 5, 6, 7, 9]
1. 이때 첫 번째 고양이(3)와 마지막 고양이(9)를 한 명이 든다고 가정하면 두 무게의 합이 12라서 한 명이 들지 못한다.
2. 이럴 땐 마지막 값만 수정해야 된다. (right - 1)
3. 첫 번째 고양이(3)와 마지막 전 고양이(7)를 합하면 10이므로 한 명이 들 수 있다.
    3.1 이때 res를 1 더하고, 두 고양이는 한 사람이 들었으므로 left, right 각각 인덱스를 1을 더하고, 1을 빼야 된다.
4. 위 과정을 반복하면 된다.

고양이를 최소 두 마리 이상 들어야 되므로 같은 인덱스에 접근하면 안 된다.
따라서, while 문 조건으로 left <= right 라는 조건을 사용해면 안 된다.
'''

n, k = map(int, input().split())
n_list = sorted(list(map(int, input().split())))

# 테스트
# n, k = 5, 20
# n_list = sorted([8, 16, 11, 2, 4]) # 2
# n, k = 6, 10
# n_list = sorted([9, 5, 6, 7, 4, 3]) # 2
# n, k = 4, 100
# n_list = sorted([100, 99, 98, 97]) # 0

left, right = 0, n - 1
res = 0

while left < right:
    if n_list[left] + n_list[right] <= k:
        res += 1
        right -= 1
        left += 1
    else:
        right -= 1

print(res)
