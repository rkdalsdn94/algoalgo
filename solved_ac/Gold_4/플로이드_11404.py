# 백준 - 골드4 - 플로이드 - 11404 - 그래프, 플로이드 와샬 문제
'''
그래프, 플로이드 와샬 문제

전형적인 플로이드 와샬 문제이다. 이 전에 풀었던 문제들을 참고하면서 해당 문제를 풀었다.

전에 풀었던 플로이드 와샬 문제는 아래와 같다.
 - '백준 - 경로 찾기(11403)' - 실버1
 - '백준 - 궁금한 민호(1507)' - 골드3
위의 문제들을 기준으로 비슷하게 풀었다. 단, 이 전의 문제들과 다른 점이 좀 있다.

'경로 찾기', '궁금한 민호' 두 문제 모두 graph 를 만들 필요가 없었기 때문에 다르고, '경로 찾기' 문제는 난이도의 낮아서 그런지 풀이가 단순하다.
그래서 많이 참고한 문제는 '궁금한 민호' 문제이다.
참고한 부분은 해당 파일 주석으로 되어 있는 '최단 거리가 아닐 경우' 이 부분만 수정하면 된다.
위의 조건을 기준으로 최단거리가 아닐때 graph 의 값을 최단 거리로 바꾸는 방식으로 처리했다.

또한, 98% 에서 '틀렸습니다.'가 나와서 역시나 질문 게시판을 참고했는데 INF 일 때 0 으로 바꾸는 방법을 단순하게 생각했다.
해당 부분을 수정한 후 문제를 통과할 수 있었다.

뭔가 어려운 듯 하면서 어느 정도는 정형화 되어 있는거 같다. (난이도가 높아지면 다르겠지만...)
계속 열심히 풀어봐야 되겠다.
'''

import sys; input=sys.stdin.readline

INF = int(1e9)

n, m = int(input()), int(input())
m_list = [ list(map(int, input().split())) for _ in range(m) ]

graph = [ [INF] * n for _ in range(n) ]
for i in m_list:
    a, b, c = i[0] - 1, i[1] - 1, i[2]
    graph[a][b] = min(graph[a][b], c)

# 테스트
# INF = int(1e9)
# n, m = 5, 14
# graph = [
#     [1000000000, 2, 3, 1, 10], [1000000000, 1000000000, 1000000000, 2, 1000000000],
#     [8, 1000000000, 1000000000, 1, 1], [1000000000, 1000000000, 1000000000, 1000000000, 3],
#     [7, 4, 1000000000, 1000000000, 1000000000]
# ]

for k in range(n): # 거처가는 노드
    for i in range(n): # 출발 노드
        for j in range(n): # 도착 노드
            if k == i or i == j or k == j:
                continue

            if graph[i][j] > graph[i][k] + graph[k][j]:
                graph[i][j] = graph[i][k] + graph[k][j]

for i in range(n):
    for j in range(n):
        if graph[i][j] == INF:
            graph[i][j] = 0

'''
98% 에서 틀린다면 생각해 볼 문제
만약 INF 의 경우가 더 한 줄의 하나 씩이 아니라 더 많이 있다면 완전 탐색처럼 그래프의 전체를 찾으면서 값을 바꿔야 된다.

for i in range(n):
    if INF in graph[i]:
        idx = graph[i].index(INF)
        graph[i][idx] = 0
'''

for i in graph:
    print(*i)
