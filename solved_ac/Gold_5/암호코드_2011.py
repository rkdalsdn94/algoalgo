# 백준 - 골드5 - 암호코드 - 2011 - dp 문제
'''
dp 문제

[핵심 아이디어]
    1. 각 위치의 숫자는 단독으로 해석하거나(1~9) 이전 숫자와 결합하여 해석(10~26)할 수 있다.
    2. dp[i]는 i번째 위치까지의 암호를 해석할 수 있는 경우의 수를 저장한다.
    3. 현재 위치에서의 해석 가능한 경우의 수는 이전 위치들의 해석 경우의 수에 의존한다.

[풀이 과정]
    1. 입력 문자열이 '0'으로 시작하면 해석이 불가능하므로 0을 반환한다.
    2. dp 배열을 초기화한다:
      - dp[0] = 1 (빈 문자열)
      - dp[1] = 1 (첫 번째 문자가 유효한 경우)
    3. 각 위치 i에 대해 두 가지 경우를 고려한다:
      - 현재 숫자(s[i - 1])가 '0'이 아니면, dp[i]에 dp[i - 1]의 값을 더한다.
      - 이전 숫자와 현재 숫자로 만든 두 자리 수가 10~26 범위이면, dp[i]에 dp[i - 2]의 값을 더한다.
    4. 모든 계산에서 1,000,000으로 나눈 나머지를 유지한다.
    5. 최종적으로 dp[n]을 반환하여 전체 문자열의 해석 가능한 경우의 수를 구한다.
'''

def solution(s):
    if s[0] == '0':  # 시작이 0인 경우는 해석 불가
        return 0

    n = len(s)
    MOD = 1000000

    # dp[i]는 s[:i + 1]까지의 문자열을 해석하는 방법의 수
    dp = [0] * (n + 1)
    dp[0] = 1  # 빈 문자열은 1가지 방법으로 해석 가능
    dp[1] = 1  # 한 자리 숫자는 1가지 방법으로 해석 가능

    for i in range(2, n + 1):
        # 한 자리 숫자로 해석하는 경우
        if s[i - 1] != '0':
            dp[i] = dp[i - 1]

        # 두 자리 숫자로 해석하는 경우
        two_digit = int(s[i - 2 : i])
        if 10 <= two_digit <= 26:
            dp[i] = (dp[i] + dp[i - 2]) % MOD

    return dp[n]

encrypted = input().strip()
print(solution(encrypted))
