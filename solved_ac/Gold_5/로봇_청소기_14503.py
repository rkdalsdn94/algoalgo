'''
구현, 시뮬레이션 문제

bfs로 단순하게 풀 생각을 했었는데, 실패한 후에 문제를 다시 읽어보니 아래와 같인 조건(?)이 있었다.

    a. 현재 위치의 바로 왼쪽에 아직 청소하지 않은 빈 공간이 존재한다면,
       왼쪽 방향으로 회전한 다음 한 칸을 전진하고 1번으로 돌아간다.
       그렇지 않을 경우, 왼쪽 방향으로 회전한다. 이때, 왼쪽은 현재 바라보는 방향을 기준으로 한다.
    b. 1번으로 돌아가거나 후진하지 않고 2a번 단계가 연속으로 네 번 실행되었을 경우,
       바로 뒤쪽이 벽이라면 작동을 멈춘다. 그렇지 않다면 한 칸 후진한다.

위에 부분을 잘 고려한 후에 문제를 풀어야된다.

그래서, 왼쪽으로 회전하는 함수(left)를 만들고,
한 칸 후진을 위해 4번 실행한지 체크할 수 있는 변수를 만들었다.(while 문 안에 temp변수)
 ㄴ> temp가 4가 됐을 때 벽이 아니면 후진할 수 있게 만들었다.

두 경우를 고려한 후에 문제를 다시 푼 후에 통과할 수 있었다.
'''

# n, m = map(int, input().split())
# r, c, d = map(int, input().split())
# board = [ list(map(int, input().split())) for _ in range(n) ]

# 테스트
n, m = 3, 3
r, c, d = 1,1,0
board = [ [1,1,1], [1,0,1], [1,1,1] ] # 1
# n, m = 11, 10
# r, c, d = 7,4,0
# board =  [ [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
#            [1, 0, 0, 0, 1, 1, 1, 1, 0, 1], [1, 0, 0, 1, 1, 0, 0, 0, 0, 1],
#            [1, 0, 1, 1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
#            [1, 0, 0, 0, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1, 1, 0, 1],
#            [1, 0, 0, 0, 0, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
#            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] ] # 57

res = 0
dx, dy = [-1,0,1,0], [0,1,0,-1]
ck = [ [0] * m for _ in range(n) ]
ck[r][c] = 1
res, temp = 1, 0

def left():
    global d
    d -= 1
    if d == -1: d = 3

while 1:
    left()
    nx, ny = r + dx[d], c + dy[d]

    if ck[nx][ny] == 0 and board[nx][ny] == 0:
        ck[nx][ny] = 1
        res += 1
        r, c = nx, ny
        temp = 0
        continue
    else:
        temp += 1
    
    if temp == 4:
        nx, ny = r - dx[d], c - dy[d]

        if board[nx][ny] == 0:
            r, c = nx, ny
        else:
            break
        temp = 0

print(res)
