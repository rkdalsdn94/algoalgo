# 백준 - 골드5 - 전깃줄 - 2565 - dp, LIS(최장 증가 부분 수열, Longest Increasing Subsequence) 문제
'''
dp, LIS(최장 증가 부분 수열, Longest Increasing Subsequence) 문제

핵심 아이디어
    - 전깃줄을 연결하는 순서를 바꾸어 최장 증가 부분 수열을 찾는다.
    - 전체 전깃줄의 개수에서 최장 증가 부분 수열의 길이를 빼면 제거해야 하는 전깃줄의 최소 개수를 구할 수 있다.

LIS가 적용되는 이유:
    전깃줄이 교차하지 않으려면, A 전봇대를 기준으로 오름차순 정렬했을 때 B 전봇대의 번호도 증가해야 합니다.
    즉, B 전봇대의 연결점이 증가하는 부분 수열을 이루어야 전선이 교차하지 않습니다.
    교차하지 않는 전깃줄의 최대 개수 = 최장 증가 부분 수열의 길이

예시를 통한 설명:
    입력된 전깃줄: [1,8], [3,9], [2,2], [4,1], [6,4], [10,10], [9,7], [7,6]
    A 기준 정렬 후:
        A:  1   2   3   4   6   7   9   10
        B:  8   2   9   1   4   6   7   10
    최장 증가 부분 수열:
        2 -> 4 -> 6 -> 7 -> 10  (길이 5)

풀이 과정
    1. N을 입력받는다.
    2. 전깃줄을 입력받는다.
    3. 전깃줄을 정렬한다.
    4. dp를 1로 초기화한다.
    5. dp를 계산한다.
    6. 결과 출력
'''

n = int(input())
n_list = sorted([list(map(int, input().split())) for _ in range(n)])

# 테스트
# n = 8
# n_list = sorted([
#     [1, 8], [3, 9], [2, 2],
#     [4, 1], [6, 4], [10, 10],
#     [9, 7], [7, 6]
# ]) # 3

dp = [1] * n

for i in range(n):
    for j in range(i):
        if n_list[i][1] > n_list[j][1]:
            dp[i] = max(dp[i], dp[j] + 1)

print(n - max(dp))
