# 백준 - 실버1 - 쉬운 최단거리 - 14940 - 그래프, bfs 문제
'''
그래프, bfs 문제

단순하게 bfs를 구현하면 되는 문제이다.
ck를 res처럼 사용해서 그대로 출력해도 되는데, 변수들의 역할을 나눠서 따로 만들었다. (ck는 체크를 하기 위한, res는 출력을 하기 위한)
board의 값 중 2부터 시작해서 상 하 좌 우 4 방향으로 bfs를 돌리면 된다.
단, res를 -1 로 초기화했기 때문에 board 에서 벽을 만나는 부분은 0으로 처리해야 된다.
  ㄴ> (문제 중 '원래 갈 수 있는 땅인 부분 중에서 도달할 수 없는 위치는 -1' 때문)

in
    15 15
    2 1 1 1 1 1 1 1 1 1 1 1 1 1 1
    1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
    1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
    1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
    1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
    1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
    1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
    1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
    1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
    1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
    1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
    1 1 1 1 1 1 1 1 1 1 0 0 0 0 1
    1 1 1 1 1 1 1 1 1 1 0 1 1 1 1
    1 1 1 1 1 1 1 1 1 1 0 1 0 0 0
    1 1 1 1 1 1 1 1 1 1 0 1 1 1 1
out
    0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
    2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
    3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
    4 5 6 7 8 9 10 11 12 13 14 15 16 17 18
    5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
    6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
    7 8 9 10 11 12 13 14 15 16 17 18 19 20 21
    8 9 10 11 12 13 14 15 16 17 18 19 20 21 22
    9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
    10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
    11 12 13 14 15 16 17 18 19 20 0 0 0 0 25
    12 13 14 15 16 17 18 19 20 21 0 29 28 27 26
    13 14 15 16 17 18 19 20 21 22 0 30 0 0 0
    14 15 16 17 18 19 20 21 22 23 0 31 32 33 34
'''

from collections import deque

n, m = map(int, input().split())
board = [ list(map(int, input().split())) for _ in range(n) ]
ck = [ [0] * m for _ in range(n) ]
res = [ [-1] * m for _ in range(n) ]
dx, dy = [1, 0, -1, 0], [0, 1, 0, -1]

def bfs(x, y):
    q = deque([(x, y, 0)])
    ck[x][y] = 1
    res[x][y] = 0

    while q:
        a, b, c = q.popleft()

        for i in range(4):
            nx, ny = a + dx[i], b + dy[i]

            if 0 <= nx < n and 0 <= ny < m and board[nx][ny] == 1 and ck[nx][ny] == 0:
                q.append([nx, ny, c + 1])
                ck[nx][ny] = 1
                res[nx][ny] = c + 1

for i in range(n):
    for j in range(m):
        if board[i][j] == 2 and ck[i][j] != 1:
            bfs(i, j)
        if board[i][j] == 0:
            res[i][j] = 0

for i in res:
    print(*i)
