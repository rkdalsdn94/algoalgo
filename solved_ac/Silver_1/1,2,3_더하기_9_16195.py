# 백준 - 실버1 - 1, 2, 3 더하기 9 - 16195 - dp 문제
'''
dp 문제

[핵심 아이디어]
    - dp[i][j]는 정수 i를 j개의 수로 표현하는 방법의 수를 나타냅니다.
    - 예를 들어 dp[4][2]는 4를 정확히 2개의 수로 표현하는 방법의 수입니다 (1 + 3, 3 + 1, 2 + 2).

주요 점화식:
    dp[i][j] = dp[i - 1][j - 1] + dp[i - 2][j - 1] + dp[i - 3][j - 1]
        - i - 1에서 1을 더하는 경우
        - i - 2에서 2를 더하는 경우
        - i - 3에서 3을 더하는 경우
    각각의 경우에서 사용된 수의 개수가 j - 1인 상태에서 1개를 더 사용하므로 j - 1을 활용합니다.

[풀이 과정]
    1. 기본 케이스 초기화:
       dp[1][1] = 1 (1)
       dp[2][1] = 1 (2)
       dp[2][2] = 1 (1+1)
       dp[3][1] = 1 (3)
       dp[3][2] = 2 (1+2, 2+1)
       dp[3][3] = 1 (1+1+1)
    2. 4부터 1000까지의 모든 수에 대해 점화식 적용:
       dp[i][j] = (dp[i-1][j-1] + dp[i-2][j-1] + dp[i-3][j-1]) % MOD
    3. 쿼리 처리:
       각 n, m에 대해 dp[n][1]부터 dp[n][m]까지의 합을 구하여 출력
       이는 n을 m개 이하의 수로 표현하는 모든 방법의 수를 의미함
'''

MOD = 1000000009
dp = [[0] * 1001 for _ in range(1001)]

dp[1][1] = 1
dp[2][1] = 1
dp[2][2] = 1
dp[3][1] = 1
dp[3][2] = 2
dp[3][3] = 1

for i in range(4, 1001):
    for j in range(1, i + 1):
        dp[i][j] = (dp[i - 1][j - 1] + dp[i - 2][j - 1] + dp[i - 3][j - 1]) % MOD

t = int(input())
t_list = [list(map(int, input().split())) for _ in range(t)]

# 테스트
# t = 3
# t_list = [
#     [4, 2], [7, 5], [10, 6]
# ] # 3  \  37  \  151
# t = 4
# t_list = [
#     [4, 1], [4, 2], [4, 3], [4, 4]
# ] # 0  \  3  \  6  \  7
# t = 7
# t_list = [
#     [7, 1], [7, 2], [7, 3], [7, 4], [7, 5], [7, 6], [7, 7]
# ] # 0  \  0  \  6  \  22  \  37  \  43  \  44
# t = 10
# t_list = [
#     [10, 1], [10, 2], [10, 3], [10, 4], [10, 5], [10, 6], [10, 7], [10, 8], [10, 9], [10, 10]
# ] # 0  \  0  \  0  \  10  \  61  \  151  \  228  \  264  \  273  \  274

for n, m in t_list:
    print(sum(dp[n][1 : m + 1]) % MOD)
