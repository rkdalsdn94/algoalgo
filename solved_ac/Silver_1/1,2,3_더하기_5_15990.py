# 백준 - 실버1 - 1, 2, 3 더하기 5 - 15990 - dp 문제
'''
dp 문제

핵심 아이디어
   - 1, 2, 3으로 숫자를 만드는 방법의 수를 구하는 문제
   - 마지막에 사용한 수를 기준으로 경우의 수를 구한다.
   - dp[i][j]에서 i는 만들려는 수, j는 마지막에 사용한 수를 의미한다. (j=0: 1로 끝남, j=1: 2로 끝남, j=2: 3으로 끝남)
   - 같은 수를 연속해서 사용할 수 없다는 조건을 처리하기 위해 마지막 사용 수를 기록한다.
   - 모든 경우의 수를 1,000,000,009로 나눈 나머지를 구한다.

풀이 과정
   1. T를 입력받는다.
   2. T만큼 반복하며 N을 입력받는다.
   3. dp 배열을 초기화한다:
      - dp[1] = [1,0,0]: 1을 만드는 방법은 1 하나뿐
      - dp[2] = [0,1,0]: 2를 만드는 방법은 2 하나뿐
      - dp[3] = [1,1,1]: 3을 만드는 방법은 1+2, 2+1, 3
   4. 4부터 100,000까지 dp 배열을 채운다:
      - i로 끝나는 수는 i를 제외한 다른 수들로 끝나는 이전 경우들의 합
   5. 각 테스트케이스마다 dp[n]의 모든 경우의 합을 1,000,000,009로 나눈 나머지를 출력한다.
'''

t = int(input())
n_list = [int(input()) for _ in range(t)]

# 테스트
# t = 3
# n_list = [4, 7, 10] # 3  \  9  \  27

# dp[i][j]: i를 만들 때 j로 끝나는 경우의 수
# j=0: 1로 끝남, j=1: 2로 끝남, j=2: 3으로 끝남
dp = [[0, 0, 0] for _ in range(100001)]

# 초기값 설정
dp[1] = [1, 0, 0]  # 1
dp[2] = [0, 1, 0]  # 2
dp[3] = [1, 1, 1]  # 1+2, 2+1, 3

# 점화식에 따라 dp 배열 채우기
for i in range(4, 100001):
    # i에서 1로 끝나는 경우: i-1이 2나 3으로 끝난 경우에 1을 붙임
    dp[i][0] = (dp[i - 1][1] + dp[i - 1][2]) % 1000000009
    # i에서 2로 끝나는 경우: i-2가 1이나 3으로 끝난 경우에 2를 붙임
    dp[i][1] = (dp[i - 2][0] + dp[i - 2][2]) % 1000000009
    # i에서 3으로 끝나는 경우: i-3이 1이나 2로 끝난 경우에 3을 붙임
    dp[i][2] = (dp[i - 3][0] + dp[i - 3][1]) % 1000000009

for n in n_list:
    print(sum(dp[n]) % 1000000009)
