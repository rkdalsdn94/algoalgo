# 백준 - 실버1 - 극장 좌석 - 2302 - dp 문제
'''
dp 문제

dp 좌석은 곱의 법칙(동시에 일어남)과 합의 법칙(동시에 일어나지 않음)을 섞어서 풀면 된다.
    - 합의 곱칙, 곱의 법칙을 까먹었다면 https://mathbang.net/543#gsc.tab=0 여기를 읽어보자.
vip 좌석을 구분적으로 vip 좌석이 아닌 좌석은 합의 법칙으로 경우의 수를 계산하고 그 그룹들을 곱해주면 된다.
합의 법칙 점화식 : dp[n] = dp[n - 1] + dp[n - 2]  (피보나치 수열)
    - dp[n] = 자리가 바뀐 경우 + 바뀌지 않은 경우
즉, vip(m)이 1보다 크거나 같을 때 해당 위치의 전의 경우의 수들과 이후의 올 경우의 수를 곱하면 된다.
    ex) n = 8, m = 2, m_list = [4, 7]
        [0, 0, 0, 1, 0, 0, 1, 0] -> 이렇게 되어 있을 때
        첫 번째 vip 4가 나오기 전 경우의 수 즉, n이 3일 때 경우의 수 3
        두 번째 vip 7이 나오기 전 경우의 수 n이 2일 때 경우의 수 2
        그 이후엔 1자리 밖에 없으므로 무시 => 3 * 2 = '6' 이 된다.
        이 부분을 temp 값을 이용해 인덱스를 계산할 때 활용했다. (메모이제이션)

풀이는 다르지만 아래의 글을 읽으면 쉽게 이해가 된다.
    - https://sdev.tistory.com/1342

전체 좌석을 구하는 방법
    좌석이 1개 일 때 : 1 (1, 한 개 밖에 없음)
    좌석이 2개 일 때 : 2 (1 2, 2 1 => 이 두 경우 밖에 없음)
    좌석이 3개 일 때 : 3 (좌석이 2개일 때 + 좌석이 1개 일 때)
    좌석이 4개 일 때 : 5 (좌석이 3개일 때 + 좌석이 2개 일 때)
        .
        .
        .
    좌석이 n개 일 때 : (좌석이 n - 1개 일 때) + (좌석이 n - 2개 일 때)
'''

n = int(input())
m = int(input())
m_list = [int(input()) for _ in range(m)]

# 테스트
# n = 9
# m = 2
# m_list = [4, 7] # 12

dp = [0] * (n + 3) # n + 1 로만 되어 있으면 index error가 나온다. (n의 범위는 1이상 40이하 이므로)
dp[0] = 1
dp[1] = 1
dp[2] = 2
res = 1

for i in range(3, n + 1):
    dp[i] = dp[i - 1] + dp[i - 2]

if m >= 1:
    temp = 0

    for i in range(m):
        res *= dp[m_list[i] - 1 - temp]
        temp = m_list[i]
    res *= dp[n - temp]
else:
    res = dp[n]

print(res)
