# 백준 - 실버1 - 회전 초밥 - 2531 - 완전 탐색 문제
'''
완전 탐색 문제

solved 문제 분류 상 투 포인터랑 슬라이딩 윈도우도 되어 있지만
뮨에서 입력으로 들어오는 최악의 시간 복잡도가 9천만 이므로 완전 탐색 방식으로만 풀어도 문제가 풀린다.
     - n의 최대 범위 30_000, k의 최대 범위 3_000 두 수를 곱한 값 즉, 90_000_000만이다.
즉, 완전 탐색 방식으로 전체 n 번의 과정에서 k번 모두 실행하는 방식으로 풀었다.
단, 완전 탐색 방식으로만 이 문제를 풀려면 PyPy3로 제출해야 된다.

아래 풀이 과정을 그로만 보기 어려우면 테스트 부분의 주석을 해제하고 다음의 링크에서 실행해보면 이해하기 쉽다.
    - https://pythontutor.com/visualize.html#mode=edit

풀이 과정
 - 입력을 잘 받고, 전체 n을 실행한다.
 - 초밥 먹은걸 체크하기 위해 ck배열을 d + 1의 크기로 만들어 주고, 쿠번으로 들어오는 초밥을 먹었다는 표시로 1 만들어 준다.
 - n번을 실행하는 도중 쿠폰 초밥을 먼저 먹었다는 표시를 하기 위해 해당 위치의 값을 1로 바꿔준다.
 - 그 후 연속해서 먹을 수 있는 초밥을 실행한다. (i부터 i + k까지)
    - 이 후 나머지 연산자를 통해 n_list의 값들을 하나 씩 꺼내면서 ck에 방문하지 않은 값이면 cnt를 증가시킨다.
    - 위 과정이 끝날 때마다 res를 max함수를 통해 res와 cnt 중 더 큰 값으로 바꿔준다
 - 전체 반복문이 끝나면 res를 출력하면 된다.
'''

n, d, k, c = map(int, input().split())
n_list = [int(input()) for _ in range(n)]

# 테스트
# n, d, k, c = 8, 30, 4, 30
# n_list = [7, 9, 7, 30, 2, 7, 9, 25] # 5
# n, d, k, c = 8, 50, 4, 7
# n_list = [2, 7, 9, 25, 7, 9, 7, 30] # 4

res = 0

for i in range(n):
    cnt = 1
    ck = [0] * (d + 1) # 초밥 먹은거 체크하는 리스트
    ck[c] = 1 # 쿠폰으로 들어오는 초밥을 먼저 먹었다는 표시

    for j in range(i, i + k): # 연속해서 먹을 수 있는 초밥을 먹는 과정
        temp = n_list[j % n]

        if not ck[temp]: # 먹지 않은 초밥이라면
            cnt += 1
        ck[temp] += 1 # 먹었다는 표시

    res = max(res, cnt)

print(res)
