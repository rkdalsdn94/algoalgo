# 백준 - 실버1 - 가장 가까운 세 사람의 심리적 거리 - 20529 - 완전 탐색, 비둘기집 원리 문제
'''
완전 탐색, 비둘기집 원리(?) 문제

'비둘기집 원리'가 먼지 몰라서 문제를 다 풀고 찾아보니 다음과 같다.
    모든 비둘기가 비둘기집에 빠짐없이 들어가야 한다는 조건 하에서,
    n + 1 마리의 비둘기와 n개의 비둘기집이 있고 한 집당 한 마리씩만 존재한다고 가정하면 (p ^ ~q),
    비둘기집 전체에는 최대 n 마리의 비둘기가 존재할 수 있게 되는데, 비둘기의 숫자는 n + 1 마리이기에
    어느 집에도 들어가지 못한 비둘기 한 마리가 남을 수밖에 없게 되므로 가정에 모순이 발생하게 된다.
    따라서 모든 비둘기집에 한마리의 비둘기만 들어가야 한다는 제한은 성립할 수 없으며,
    이에 따라 "n + 1 마리의 비둘기를 n개의 비둘기집에 넣는다면, 적어도 하나의 비둘기집에는 두 마리 이상의 비둘기가 존재한다. p -> q"가 참이 된다.
    비둘기 집의 원리에 대한 문제를 구할 때에 아니면 표현할 때에는 올림 기호를 사용한다.

처음에는 비둘기집 원리를 모르고 완전 탐색 방식으로 풀었다가 '시간 초과'를 맞았다.
비둘기집 원리를 이용해 n이 32 보다 크면 0을 출력하면 된다. 그 이하는 완전 탐색으로 풀면 된다.
    - 비둘기집 원리 활용 : mbti는 16가지, 17명이면 2명은 같은 mbti, 33명이면 3명의 mbti는 같으므로 0을 출력하면 된다.
    - 문제는 3 세 사람의 가장 가까운 세 학생의 거리를 구하는 것이므로 0을 출력하면 된다.

풀이 과정
- t 만큼 반복하면서 n을 입력받는다.
- n이 32보다 클 경우 비둘기집 원리를 이용해 '0'을 출력한다.
- 32보다 작을 경우 combination을 활용해 3개의 조합으로 만들고 완전 탐색 방식으로 다른 mbti의 수를 세면 된다.

in
    3
    3
    ENTJ INTP ESFJ
    4
    ESFP ESFP ESFP ESFP
    5
    INFP INFP ESTP ESTJ ISTJ
out
    8
    0
    4
'''

from itertools import combinations as combi

t = int(input())
for _ in range(t):
    n = int(input())
    n_list = list(input().split())
    res = float('inf')

    if n > 32:
        print(0)
        continue

    for i, j, k in combi(n_list, 3):
        temp = 0
        for z in range(4):
            if i[z] != j[z]:
                temp += 1
            if i[z] != k[z]:
                temp += 1
            if j[z] != k[z]:
                temp += 1
        res = min(res, temp)
    print(res)
