# 백준 - 실버4 - 자리배정 - 10157 - 구현, 완전 탐색 문제
'''
구현, 완전 탐색 문제

아래 풀이 과정이 길면 정답으로 제출한 코드만 봐도 파악이 가능하다.
달팽이 문제와 유사하다. 비슷한 방식으로 풀면 된다.
단, 문제에선 3, 3으로 주어졌을 때 정답을 구하기 편하게 board를 돌려서 생각해야 된다.
 ex) 3, 3 일 때 (문제에선 왼쪽으로 주어지지만 오른쪽 방식으로 구하는게 편함)
        3 4 5      1 8 7
        2 9 6  ->  2 9 6
        1 8 7      3 4 5
 입력이 위처럼 들어올 때 7의 위치는 오른쪽 방식으로 계산하면 (1, 3) 이다. 단, 출력을 y, x 형식으로 해야 된다.
 y, x 형식으로 출력하면 문제의 정답이랑 같다.

풀이 과정
 - board를 만드는 데 입력받는 값 그대로 사용하기 위해 보드의 바깥을 1로 둘러싸서 만든다. (이렇게 하면 범위 체크를 하지 않아도 됨)
    ex) 3, 3이면 다음과 같이 만든다.
            1 1 1 1 1
            1 0 0 0 1
            1 0 0 0 1
            1 0 0 0 1
            1 1 1 1 1
 - 1부터 k까지 반복하면서 k의 위치가 되었을 때 i와 j를 출력하면 된다.
     - 단, c * r이 k보다 작으면 어차피 범위를 벗어나게 되므로 0을 출력하고 프로그램을 종료하면 된다.
 - c * r이 k보다 작으면 1부터 k까지 반복하면서 board를 만든다.
    - 이때 0이 아닌 숫자가 만났을 때 방향을 바꿔야 된다.
    - 방향의 순서는 하, 우, 상, 좌 순서로 구하면 된다.
 - k에 도달했을 때 (y, x) 형식으로 출력하면 된다.
'''

c, r = map(int, input().split())
k = int(input())

# 테스트
# c, r = 7, 6
# k = 11 # 6 6
# c, r = 3, 3
# k = 10 # 0
# c, r = 3, 3
# k = 7 # 3 1

board = [[1] * (c + 2)] + [[1] + [0] * c + [1] for _ in range(r)] + [[1] * (c + 2)]
dx, dy = [1, 0, -1, 0], [0, 1, 0, -1] # 아래, 오른쪽, 위, 왼쪽
x, y, direction = 1, 1, 0
res = 0

if k > c * r:
    print(0)
    exit(0)

for i in range(1, k):
    board[x][y] = i # board를 만드는 과정
    nx, ny = x + dx[direction], y + dy[direction] # 다음의 값이 board를 벗어나는지 체크 + 값이 있는지 확인하기 위해

    if board[nx][ny] == 0: # 0이면 벗어나지도 않고, 값도 없는 상황
        x, y = nx, ny
    else: # 0이 아니면 방향을 바꿔야 됨
        direction = (direction + 1) % 4
        x, y = x + dx[direction], y + dy[direction]

print(y, x)
