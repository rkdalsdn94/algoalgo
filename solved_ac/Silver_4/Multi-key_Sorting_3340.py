# 백준 - 실버4 - Multi-key Sorting - 3340 - 자료 구조(set), 정렬 문제
'''
자료 구조(set), 정렬 문제

정렬 명령들의 순서를 최적화하는 문제이다. (정렬 명령들을 최소한으로 줄이는 문제, 결과는 같아야 함)
즉, 여러 번의 정렬 명령을 최적화하여, 동일한 결과를 내는 가장 짧은 정렬 순서를 찾는 문제

문제 해석
1. 입력으로 주어지는 정렬 명령은 각 열을 기준으로 하는 안정 정렬이다.
2. 안정 정렬이란 같은 값을 가진 항목들의 상대적 순서가 유지되는 정렬이다.
3. 정렬 명령의 순서가 결과에 영향을 미친다. (예: Sort(1), Sort(2)와 Sort(2), Sort(1)은 다른 결과)

해결 방법
1. 뒤에서부터 정렬 명령을 확인한다.
    1.1. 마지막 정렬이 전체 결과에 가장 큰 영향을 미치기 때문
    1.2. 이전 정렬들은 같은 값을 가진 항목들 사이에서만 영향을 미침
2. 중복된 정렬 명령은 제거한다.
    2.1. 같은 열에 대한 연속된 정렬은 한 번만 수행해도 됨
3. 정렬 명령을 원래 순서대로 재배열한다.
    3.1. 뒤에서부터 모은 명령들을 다시 뒤집어서 반환

최적화가 가능한 이유
1. 안정 정렬의 특성으로 인해 이전 정렬의 일부 영향이 유지된다.
2. 정렬의 영향이 계층적으로 적용된다.
    - 마지막 정렬: 전체 데이터에 영향
    - 이전 정렬: 마지막 정렬 기준으로 같은 값을 가진 항목들에만 영향
'''

C, N = map(int, input().split())
sorts_cmd = list(map(int, input().split()))

# 테스트
# C, N = 4, 6
# sorts_cmd = [1, 2, 1, 2, 3, 3] # 3  \  1 2 3
# C, N = 2, 4
# sorts_cmd = [1, 2, 2, 1] # 2  \  2 1

def optimize_sorts(C, N, sorts_cmd):
    # 결과를 저장할 리스트와 이미 본 정렬 명령을 기록할 set
    result = []
    seen = set()

    # 뒤에서부터 순회합니다
    for i in range(N-1, -1, -1):  # N-1부터 0까지
        col = sorts_cmd[i]  # 현재 정렬 명령

        # 이 열 번호로 처음 정렬하는 경우라면
        if col not in seen:
            # 결과 리스트에 추가
            result.append(col)
            # 본 적 있는 열 번호로 기록
            seen.add(col)

    # 뒤에서부터 모았으니 다시 뒤집어서 반환
    return result[::-1]

res = optimize_sorts(C, N, sorts_cmd)

print(len(res))
print(*res)
