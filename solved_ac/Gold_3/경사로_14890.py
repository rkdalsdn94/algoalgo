# 백준 - 골드3 - 경사로 - 14890 - 구현, 시뮬레이션 문제
'''
구현, 시뮬레이션 문제

경사로를 놓을 수 있는지 확인하는 문제이다.
경사로를 놓을 수 있는지 확인하는 방법은 다음과 같다.
1. 경사로를 놓을 수 있는 길인지 확인한다.
    1.1. 길의 높이가 2 이상 차이나면 경사로를 놓을 수 없다.
2. 경사로를 놓을 수 있는 길이라면 경사로를 놓는다.
    2.1. 경사로를 놓을 때 경사로의 길이만큼 놓을 수 있는지 확인한다.
    2.2. 경사로를 놓을 수 있다면 경사로를 놓고, 경사로를 놓은 길을 체크한다.
3. 길의 끝까지 도달했을 때, 경사로를 놓을 수 있는 길이라면 cnt를 1 증가시킨다.

check 함수를 하나만 둬서 행을 왼쪽에서 오른쪽으로 한 번, 오른쪽에서 왼쪽으로 한 번 검사할 수 있게 만들었다.
    - 이 부분에 대한 힌트는 https://www.youtube.com/watch?v=C0djCwE_Kko 여기서 얻었다.

풀이 과정
1. 입력을 받는다.
2. 가로, 세로 길이만큼 반복문을 돌면서 각각의 길에 대해서 경사로를 놓을 수 있는지 확인한다.
    2.1. 가로 길에 대해서 확인한다.
    2.2. 세로 길에 대해서 확인한다.
    2.3. 가로 줄 세로줄 모두 통과한다면 True를 리턴해 res를 1 증가시칸다.
    2.4. 열(세로 줄)을 행으로 바꿔 위 과정을 반복한다.
3. res를 출력한다.
'''

n, l = map(int, input().split())
board = [list(map(int, input().split())) for _ in range(n)]

# 테스트
# n, l = 6, 2
# board = [
#     [3, 3, 3, 3, 3, 3],
#     [2, 3, 3, 3, 3, 3],
#     [2, 2, 2, 3, 2, 3],
#     [1, 1, 1, 2, 2, 2],
#     [1, 1, 1, 3, 3, 1],
#     [1, 1, 2, 3, 3, 2]
# ] # 3
# n, l = 6, 2
# board = [
#     [3, 2, 1, 1, 2, 3],
#     [3, 2, 2, 1, 2, 3],
#     [3, 2, 2, 2, 3, 3],
#     [3, 3, 3, 3, 3, 3],
#     [3, 3, 3, 3, 2, 2],
#     [3, 3, 3, 3, 2, 2]
# ] # 7
# n, l = 6, 3
# board = [
#     [3, 2, 1, 1, 2, 3],
#     [3, 2, 2, 1, 2, 3],
#     [3, 2, 2, 2, 3, 3],
#     [3, 3, 3, 3, 3, 3],
#     [3, 3, 3, 3, 2, 2],
#     [3, 3, 3, 3, 2, 2]
# ] # 3
# n, l = 6, 1
# board = [
#     [3, 2, 1, 1, 2, 3],
#     [3, 2, 2, 1, 2, 3],
#     [3, 2, 2, 2, 3, 3],
#     [3, 3, 3, 3, 3, 3],
#     [3, 3, 3, 3, 2, 2],
#     [3, 3, 3, 3, 2, 2]
# ] # 11

res = 0

def check(li, ck):
    cnt = 1

    for i in range(1, n):
        if li[i - 1] == li[i]:
            cnt += 1
        elif li[i - 1] + 1 == li[i] and cnt >= l and ck[i - l:i] == [0] * l:
            cnt = 1
            ck[i - l:i] = [1] * l
        elif li[i - 1] > li[i]:
            cnt = 1
        else:
            return False

    return True

for _ in range(2): # 행을 기준으로 검사, 열을 기준으로 검사 총 2 번을 수행하기 위해
    for i in board:
        ck = [0] * n

        if check(i, ck) and check(i[::-1], ck[::-1]): # 왼쪽에서 오른쪽, 오른쪽에서 왼쪽으로 검사
            res += 1

    board = list(map(list, zip(*board)))

print(res)
