# 백준 - 과제 - 13904 - 골드3 - 정렬, 우선순위 큐(힙), 자료 구조, 그리디 문제
'''
정렬, 우선순위 큐(힙), 자료 구조, 그리디 문제

heapq 자료 구조에 입력받은 과제 마감일과 과제의 점수를 n_list에 추가한다.
 - python에서는 max heap을 지원하지 않기 때문에 max heap으로 사용하려면 다른 방식이 필요하다.
 - 해당 값을 음수로 바꾼 후 max heap처럼 사용할 수 있다. -> 그래서 n_list에 과제 정보를 추가할 때 -b를 같이 추가해준다.

위의 방법 진행하고 나면 동일한 과제 마감일에 과제 점수가 더 높은 순으로 정렬할 수 있다.
같은 과제 마감일에 가장 높은 점수를 res를 추가해 준다.
 - 해당 값이 들어 있다면 다른 날에 점수가 큰 과제를 진행할 수 있는지 체크하기 위해 반복문을 res의 인덱스 역순으로 확인해보면 된다.
 - 전날에 과제를 할 수 있다면, 해당 값을 과제 점수로 바꿔준다.

뭔가 설명이 장황하고, 빈약하지만...
간단히 요약하면 결국엔 과제의 점수 순으로 정렬하는 것이 맞다. (어떻게 정렬하는지가 핵심...)
대신, 점수가 가장 큰 과제는 해당 과제의 마감일에 해야 더 큰 점수를 획득할 수 있다.
 - 위 조건 때문에 그리디 문제인거 같다.
'''

import heapq as hq

n = int(input())
res = [0] * 1_001
n_list = []

for _ in range(n):
    a, b = map(int, input().split())
    n_list.append([-b, a, b])

# 테스트
# n = 7
# n_list = [ [ -60, 4, 60], [ -40, 4, 40], [ -20, 1, 20],
#     [ -50, 2, 50], [ -30, 3, 30], [ -10, 4, 10], [ -5, 6, 5] ] # 185
# res = [0] * (n + 1)

hq.heapify(n_list)

while n_list:
    temp = hq.heappop(n_list)

    for i in range(temp[1], 0, -1):
        if res[i] == 0:
            res[i] = temp[2]
            break

print(sum(res))
