# 백준 - 실버5 - 투자의 귀재 배주형 - 19947 - dp, 완전 탐색 문제
'''
dp, 완전 탐색 문제

의외로 헤맨 문제이다. dp 배열을 사용하지 않고 3 번의 for문으로 각각 1년마다 3년마다 5년마다 이런 식으로 이상하게 접근해서 헤맸다.
헤매다가 이렇게 풀면 코드가 너무 난잡해져서 방식을 수정하고 dp를 사용했다.
0으로 초기화한 dp을 y + 1의 크기로 만든 다음 0번째 인덱스의 h의 값을 둔다.

1부터 y + 1의 크기로 for문을 실행하면서
    - 5보다 크면 (3년 전의 가격, 1년 전의 가격, 5년전의 가격) 각각의 이율을 곱한 뒤 제일 큰 값을 현재 인덱스의 값으로 만들어 준다.
    - 3보다 크면 (3년 전의 가격, 1년 전의 가격) 각각의 이율을 곱한 뒤 제일 큰 값을 현재 인덱스의 값
    - 나머진 1년마다 발생하는 이율을 곱하고 현재 인덱스의 값으로 사용하면 된다.
    - 소수점 이하의 수는 버려야 되므로 위 값들을 계산한 뒤 int 형으로 변환해서 소수점 이하를 버린다.
위 과정을 진행하고, dp의 마지막 값을 출력하면 된다.

다 풀고나면 간단한 문제인데, 처음 접근을 이상하게 해서 그런지 시간을 꽤 쏟은거 같다.
'''

h, y = map(int, input().split())

# 테스트
# h, y = 95229, 3 # 114274
# h, y = 25542, 10 # 46549

dp = [0] * (y + 1)
dp[0] = h

for i in range(1, y + 1):
    if i >= 5:
        dp[i] = int(max(dp[i - 1] * 1.05, dp[i - 3] * 1.2, dp[i - 5] * 1.35))
    elif i >= 3:
        dp[i] = int(max(dp[i - 1] * 1.05, dp[i - 3] * 1.2))
    else:
        dp[i] = int(dp[i - 1] * 1.05)

print(dp[-1])
