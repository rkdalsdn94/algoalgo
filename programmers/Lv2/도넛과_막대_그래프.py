# 프로그래머스 - Lv2 - 도넛과 막대 그래프 - 그래프, 구현 문제
'''
그래프, 구현 문제

문제를 계속 풀다가 감이 안와 다음의 블로그를 기반으로 공부했다. (사실상 거의 따라친 수준)
 - https://rovictory.tistory.com/209
 - 단, 위 블로그대로 하면 35번 문제에서 틀린다. s_node를 구할 때 in_cnt가 0보다 큰지 확인해야 한다.

출력하는 방식은 다음과 같다.
[생성한 정점의 번호, 도넛 모양 그래프의 수, 막대 모양 그래프의 수, 8자 모양 그래프의 수]

도넛과 막대 그래프는 다음과 같은 특징을 가진다.
 정점(p_node) : 나가는 간선이 2개 이상이고 들어오는 간선이 없다면 정점
 도넛 모양(d_node) : 정점에서 나가는 간선의 개수 - 막대모양 도형 개수 - 8자 모양 도형 개수
 막대 모양(s_node) : 정점에서 나가는 간선의 개수가 0개인 그래프
 8자 모양(node_8) : 정점에서 나가는 간선의 개수가 2개 이상이고, 정점으로 들어오는 간선의 개수가 2개 이상인 그래프

풀이 과정
 1. 최대 노드 숫자 구하기
 2. 각 노드의 나가는 간선과 들어오는 간선을 리스트로 구성
 3. 나가는 간선이 없다면 막대모양
 4. 나가는 간선이 2개 이상이고 들어오는 간선이 없다면 정점
 5. 나가는 간선이 2개이고 들어오는 간선이 2개 이상이면 8자 모양
 6. 도형 모양 = 정점에서 나가는 간선의 개수 - 막대모양 도형 개수 - 8자 모양 도형 개수
 7. 결과를 반환한다.
'''

def solution(edges):
    # 최대 노드 숫자 구하기
    max_node = max([i for sub in edges for i in sub])

    # 각 노드의 나가는 간선과 들어오는 간선을 리스트로 구성
    out_in = [[0, 0] for _ in range(max_node)]

    for start_node, end_node in edges:
        out_in[start_node - 1][0] += 1
        out_in[end_node - 1][1] += 1

    p_node = s_node = node_8 = 0

    for idx, node in enumerate(out_in):
        out_cnt, in_cnt = node

        # 나가는 간선이 없다면 막대모양
        if out_cnt == 0 and in_cnt > 0:
            s_node += 1
        # 나가는 간선이 2개 이상이고 들어오는 간선이 없다면 정점
        elif out_cnt >= 2 and in_cnt == 0:
            p_node = idx + 1
        # 나가는 간선이 2개이고 들어오는 간선이 2개 이상이면 8자모양
        elif out_cnt == 2 and in_cnt >= 2:
            node_8 += 1

    # 도넛 모양 = 정점에서 나가는 간선의 개수 - 막대모양 도형 개수 - 8자 모양 도형 개수
    d_node = out_in[p_node - 1][0] - s_node - node_8
    answer = [p_node, d_node, s_node, node_8]

    return answer

print(solution([[2, 3], [4, 3], [1, 1], [2, 1]])) # [2, 1, 1, 0]
edges = [[4, 11], [1, 12], [8, 3], [12, 7], [4, 2], [7, 11], [4, 8], [9, 6], [10, 11], [6, 10], [3, 5], [11, 1], [5, 3], [11, 9], [3, 8]]
print(solution(edges)) # [4, 0, 1, 2]
