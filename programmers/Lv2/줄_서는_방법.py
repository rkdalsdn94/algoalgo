# 프로그래머스 - Lv2 - 줄 서는 방법 - 수학, 조합론
"""
수학, 조합론

처음에 단순하게 permuations를 사용해서 완전 탐색 방식으로 풀었다가 효율성 테스트에서 시간 초과가 나왔다.
효율성 테스트 통과를 위해 <팩토리얼 진법 개념>을 활용하면 모든 순열을 생성하지 않고도 k번째 순열을 O(n²) 시간 복잡도로 계산할 수 있다.

[핵심 아이디어]
    1. 팩토리얼을 이용하여 각 자리에 올 숫자를 결정
    2. k와 (n-1)!을 이용하여 첫 번째 자리에 올 숫자의 인덱스를 계산
    3. 남은 숫자들로 같은 방식을 반복하여 모든 자리를 채움

[풀이 과정]
    1. 가능한 숫자들의 리스트 생성 (1부터 n까지)
    2. k를 인덱스로 사용하기 위해 k-1로 조정 (0-indexed)
    3. 각 자리(n부터 1까지)에 대해:
       a. (n-1)! 계산하여 첫 번째 자리 결정에 필요한 경우의 수 파악
       b. k를 (n-1)!로 나눈 몫을 구해 현재 자리에 올 숫자의 인덱스 결정
       c. 결정된 숫자를 결과 리스트에 추가하고 가능한 숫자 리스트에서 제거
       d. k를 (n-1)!로 나눈 나머지로 업데이트하여 다음 자리 결정에 사용
    4. 완성된 순열 반환
"""

import math

def solution(n, k):
    answer = []
    numbers = list(range(1, n+1))
    k -= 1  # 0-indexed로 변환

    for i in range(n, 0, -1):
        # 현재 자리에 대한 경우의 수
        factorial = math.factorial(i-1)
        # 현재 자리에 올 숫자의 인덱스
        idx = k // factorial
        # 결정된 숫자를 결과에 추가
        answer.append(numbers.pop(idx))
        # 다음 자리를 결정하기 위한 k 업데이트
        k %= factorial

    return answer

print(solution(3, 5) == [3,1,2])
