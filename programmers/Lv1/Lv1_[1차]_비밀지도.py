# 프로그래머스 - Lv1 - 비밀지도 - 비트 연산, 2진수 변환, 문자열 처리
"""
비트 연산, 2진수 변환, 문자열 처리 문제

- 다시 풀어보는 문제
    - 아이디어, 풀이 과정 추가
    - 기존 함수 변경 (rjust 함수에서 zfill 함수로 변경)
    - replace 함수 메서드 체이닝 방식으로 변경

[핵심 아이디어]
    1. 두 지도의 겹침은 비트 OR 연산(|)으로 구현할 수 있다.
    2. 이진수 변환 후 길이 조정을 위해 zfill() 함수를 활용한다.
    3. 이진수의 '1'은 벽('#'), '0'은 공백(' ')으로 치환한다.

[풀이 과정]
    1. 두 배열(arr1, arr2)의 원소들을 순회하며 각 원소 쌍마다:
       a. 비트 OR 연산(|)을 수행하여 두 지도를 겹친 결과를 얻는다.
       b. bin() 함수로 이진수로 변환하고, [2:]로 '0b' 접두사를 제거한다.
       c. zfill(n)을 사용해 n자리 이진수로 길이를 맞춘다.
       d. replace() 함수로 '1'은 '#'으로, '0'은 ' '(공백)으로 변환한다.
       e. 변환된 문자열을 결과 배열에 추가한다.
    2. 완성된 비밀지도 배열을 반환한다.
"""

def solution(n, arr1, arr2):
    answer = []

    for i, j in zip(arr1, arr2):
        temp = bin(i | j)[2:].zfill(n)
        temp = temp.replace('1', '#').replace('0', ' ')
        answer.append(temp)

    return answer

res = ["#####","# # #", "### #", "#  ##", "#####"]
print(solution( 5, [9, 20, 28, 18, 11], [30, 1, 21, 17, 28] ) == res)
res = ["######", "###  #", "##  ##", " #### ", " #####", "### # "]
print(solution(6, [46, 33, 33 ,22, 31, 50], [27 ,56, 19, 14, 14, 10]) == res)
